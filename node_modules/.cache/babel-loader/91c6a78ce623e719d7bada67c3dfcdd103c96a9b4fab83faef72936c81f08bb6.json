{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\e08f\\\\Desktop\\\\Proyectos\\\\Resumen\\\\mapa-v2\\\\src\\\\components\\\\IconMarkersLayer.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport ReactDOM from 'react-dom/client';\nimport { createCustomIcon } from '../utils/iconHelpers';\nimport { guardarCoordenadaCorregida } from '../services/apiService';\nimport MapPopup from './MapPopup';\nimport '../styles/iconMarkersLayer.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst IconMarkersLayer = ({\n  markers,\n  markersForMercado = null,\n  selectedRegion,\n  baseCompData = []\n}) => {\n  _s();\n  const map = useMap();\n  const markersRef = useRef({});\n  const guerraMarkersRef = useRef({});\n  const competenciaMarkersRef = useRef([]);\n  const polylineRef = useRef([]);\n  const [showingAssociated, setShowingAssociated] = useState(false);\n  const [activeMercadoPbl, setActiveMercadoPbl] = useState(null);\n  const [modoCorreccion, setModoCorreccion] = useState(null);\n\n  // --- Helpers de limpieza ---\n  const clearCompetenciaMarkers = useCallback(() => {\n    competenciaMarkersRef.current.forEach(marker => {\n      try {\n        if (map && map.hasLayer(marker)) map.removeLayer(marker);\n      } catch (e) {}\n    });\n    competenciaMarkersRef.current = [];\n  }, [map]);\n  const clearPolylines = useCallback(() => {\n    polylineRef.current.forEach(line => {\n      try {\n        if (map && map.hasLayer(line)) map.removeLayer(line);\n      } catch (e) {}\n    });\n    polylineRef.current = [];\n  }, [map]);\n  const clearGuerraMarkers = useCallback(() => {\n    Object.values(guerraMarkersRef.current).forEach(marker => {\n      try {\n        if (map && map.hasLayer(marker)) map.removeLayer(marker);\n      } catch (e) {}\n    });\n    guerraMarkersRef.current = {};\n  }, [map]);\n\n  // --- Handlers ---\n  const handleActivateCoords = useCallback(marker => {\n    if (map) map.getContainer().style.cursor = 'crosshair';\n    setModoCorreccion({\n      pbl: marker.pbl,\n      id: marker.id,\n      eds: marker.eds,\n      marca: marker.Marca,\n      lat: null,\n      lng: null\n    });\n  }, [map]);\n  const handleSaveCoords = useCallback(async marker => {\n    if (!modoCorreccion || !modoCorreccion.lat || !modoCorreccion.lng) return;\n    try {\n      const coordenada = {\n        id: marker.id || marker.pbl,\n        pbl: marker.pbl || marker.id,\n        eds: marker.eds || '',\n        marca: marker.Marca || '',\n        comuna: marker.Comuna || '',\n        lat_corregida: modoCorreccion.lat,\n        lon_corregida: modoCorreccion.lng\n      };\n      await guardarCoordenadaCorregida(coordenada);\n\n      // Actualizar marcador localmente\n      marker.lat = modoCorreccion.lat;\n      marker.lng = modoCorreccion.lng;\n\n      // Resetear modo corrección\n      setModoCorreccion(null);\n      if (map) map.getContainer().style.cursor = '';\n\n      // Re-renderizar marcadores (esto forzará un update del efecto principal)\n      // Nota: En una app real, deberíamos actualizar el estado 'markers' en el padre\n      // pero aquí simulamos el refresco limpiando y dejando que el efecto corra.\n      // Para simplificar, forzamos un re-render limpiando refs (el efecto lo notará si markers cambia, \n      // pero como mutamos el objeto, necesitamos forzar update o confiar en que el padre refresque).\n      // Aquí asumimos que el padre refrescará o que el efecto de abajo se encargará si cambiamos algo.\n      // Como mutamos 'marker', React no detecta cambio de prop 'markers' si es el mismo array.\n      // Forzamos limpieza manual y re-creación:\n      Object.values(markersRef.current).forEach(m => {\n        if (map.hasLayer(m)) map.removeLayer(m);\n      });\n      markersRef.current = {};\n      clearGuerraMarkers();\n\n      // Disparamos un evento custom o callback si fuera necesario, \n      // por ahora confiamos en que el usuario recargue o que el efecto se dispare si cambiamos algo de estado.\n      // Un truco es setear un estado dummy para forzar re-render, pero mejor dejemos que el flujo siga.\n    } catch (error) {\n      console.error(\"Error guardando coordenadas:\", error);\n    }\n  }, [modoCorreccion, map, clearGuerraMarkers]);\n\n  // --- Lógica de Mercado (Show Associated) ---\n  const showAssociatedIds = useCallback((pbl, lat, lng, originalMarkerId) => {\n    const searchArray = markersForMercado && markersForMercado.length > 0 ? markersForMercado : markers;\n    if (showingAssociated && activeMercadoPbl === pbl) {\n      // Toggle OFF\n      clearCompetenciaMarkers();\n      clearPolylines();\n      setShowingAssociated(false);\n      setActiveMercadoPbl(null);\n\n      // Restaurar marcadores originales\n      Object.values(markersRef.current).forEach(marker => {\n        try {\n          if (map && map.hasLayer(marker)) map.removeLayer(marker);\n        } catch (e) {}\n      });\n      markersRef.current = {};\n\n      // Re-crear todos\n      markers.forEach(marker => {\n        const leafletMarker = createMarkerWithPopup(marker, markersForMercado || markers, 'primary');\n        if (leafletMarker) {\n          map.addLayer(leafletMarker);\n          markersRef.current[marker.id] = leafletMarker;\n          addGuerraMarker(marker);\n        }\n      });\n      return;\n    }\n\n    // Toggle ON (o cambio de PBL)\n    clearCompetenciaMarkers();\n    clearPolylines();\n    const associatedData = baseCompData.filter(item => String(item.pbl).trim() === String(pbl).trim());\n    if (associatedData.length === 0) return;\n    const ids = associatedData.map(item => item.id);\n\n    // Limpiar actuales\n    Object.values(markersRef.current).forEach(marker => {\n      try {\n        if (map && map.hasLayer(marker)) map.removeLayer(marker);\n      } catch (e) {}\n    });\n    markersRef.current = {};\n    clearGuerraMarkers();\n\n    // Mostrar original\n    const originalMarker = markers.find(m => m.id === originalMarkerId);\n    if (originalMarker) {\n      const leafletMarker = createMarkerWithPopup(originalMarker, markersForMercado || markers, 'primary');\n      if (leafletMarker) {\n        map.addLayer(leafletMarker);\n        markersRef.current[originalMarker.id] = leafletMarker;\n        addGuerraMarker(originalMarker);\n      }\n    }\n\n    // Mostrar competencia\n    const associatedMarkers = searchArray.filter(item => ids.includes(item.id));\n    const uniqueAssociatedMarkers = [];\n    const seenIds = new Set();\n    associatedMarkers.forEach(marker => {\n      if (!seenIds.has(marker.id)) {\n        seenIds.add(marker.id);\n        uniqueAssociatedMarkers.push(marker);\n      }\n    });\n    uniqueAssociatedMarkers.forEach(marker => {\n      const leafletMarker = createMarkerWithPopup(marker, markersForMercado || baseCompData, 'secondary');\n      if (leafletMarker) {\n        map.addLayer(leafletMarker);\n        competenciaMarkersRef.current.push(leafletMarker);\n        if (marker.Guerra_Precio === 'Si') {\n          // Guerra marker logic for secondary\n          const guerraIcon = L.icon({\n            iconUrl: `${process.env.PUBLIC_URL}/iconos/calavera.jpg`,\n            iconSize: [15, 15],\n            iconAnchor: [7.5, 7.5],\n            className: 'icono-guerra'\n          });\n          const guerraMarker = L.marker([marker.lat, marker.lng], {\n            icon: guerraIcon,\n            interactive: false\n          });\n          map.addLayer(guerraMarker);\n          // No lo guardamos en ref global para no borrarlo accidentalmente con clearGuerraMarkers si solo queremos borrar los principales, \n          // aunque aquí borramos todo al cambiar de vista.\n          // Para simplificar, los agregamos a competenciaMarkersRef si queremos limpiarlos con eso, o los dejamos sueltos (pero hay que limpiarlos).\n          // Mejor los metemos en competenciaMarkersRef también (aunque sean markers distintos).\n          competenciaMarkersRef.current.push(guerraMarker);\n        }\n      }\n    });\n\n    // Polylines\n    const mainMarkersData = associatedData.filter(m => m.Marcador_Principal === 'Si');\n    mainMarkersData.forEach(mainMarker => {\n      const markerWithCoords = searchArray.find(m => m.id === mainMarker.id);\n      if (!markerWithCoords) return;\n      const mainLat = parseFloat(markerWithCoords.lat);\n      const mainLng = parseFloat(markerWithCoords.lng);\n      if (isNaN(mainLat) || isNaN(mainLng)) return;\n      const polyline = L.polyline([[parseFloat(lat), parseFloat(lng)], [mainLat, mainLng]], {\n        color: '#FF6B6B',\n        weight: 3,\n        opacity: 0.8,\n        dashArray: '5, 5'\n      }).addTo(map);\n      polylineRef.current.push(polyline);\n    });\n    setShowingAssociated(true);\n    setActiveMercadoPbl(pbl);\n  }, [baseCompData, markers, markersForMercado, map, showingAssociated, activeMercadoPbl, clearCompetenciaMarkers, clearPolylines, clearGuerraMarkers]); // createMarkerWithPopup is defined below, using ref to avoid circular dep or hoisting issues if possible, or just define it before.\n\n  // Helper para Guerra Marker\n  const addGuerraMarker = marker => {\n    if (marker.Guerra_Precio === 'Si') {\n      const guerraIcon = L.icon({\n        iconUrl: `${process.env.PUBLIC_URL}/iconos/calavera.jpg`,\n        iconSize: [15, 15],\n        iconAnchor: [7.5, 7.5],\n        className: 'icono-guerra'\n      });\n      const guerraMarker = L.marker([marker.lat, marker.lng], {\n        icon: guerraIcon,\n        interactive: false\n      });\n      map.addLayer(guerraMarker);\n      guerraMarkersRef.current[marker.id] = guerraMarker;\n    }\n  };\n\n  // --- Crear Marcador con Popup React ---\n  const createMarkerWithPopup = useCallback((marker, allMarkers, variant = 'primary') => {\n    const lat = parseFloat(marker.lat);\n    const lng = parseFloat(marker.lng);\n    if (isNaN(lat) || isNaN(lng)) return null;\n    const iconUrl = createCustomIcon(marker.Marca);\n    const leafletMarker = L.marker([lat, lng], {\n      icon: iconUrl\n    });\n\n    // Popup vacío inicial\n    const popup = L.popup({\n      autoClose: false,\n      closeOnClick: false,\n      keepInView: true,\n      autoPan: false,\n      maxWidth: 450,\n      className: 'custom-popup'\n    }).setContent('<div id=\"popup-root-' + marker.id + '\"></div>');\n    leafletMarker.bindPopup(popup);\n\n    // Renderizar React en el Popup al abrir\n    leafletMarker.on('popupopen', e => {\n      const container = e.popup._contentNode; // o _container\n      // Buscar el div root que pusimos\n      // Nota: Leaflet a veces envuelve el contenido.\n      // Mejor estrategia: usar el contenido del popup como container.\n\n      // Esperamos un tick para asegurar que el DOM existe\n      setTimeout(() => {\n        const rootDiv = document.getElementById('popup-root-' + marker.id);\n        if (rootDiv && !rootDiv._reactRoot) {\n          const root = ReactDOM.createRoot(rootDiv);\n          rootDiv._reactRoot = root;\n          root.render(/*#__PURE__*/_jsxDEV(MapPopup, {\n            marker: marker,\n            allMarkers: allMarkers,\n            onShowAssociated: showAssociatedIds,\n            onActivateCoords: handleActivateCoords,\n            onSaveCoords: handleSaveCoords,\n            modoCorreccion: modoCorreccion\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 265,\n            columnNumber: 13\n          }, this));\n        }\n      }, 0);\n    });\n    leafletMarker.on('popupclose', e => {\n      const rootDiv = document.getElementById('popup-root-' + marker.id);\n      if (rootDiv && rootDiv._reactRoot) {\n        // Desmontar para evitar leaks\n        // rootDiv._reactRoot.unmount(); // A veces da problemas si se cierra muy rápido, pero es buena práctica.\n        // Dejamos que React maneje la limpieza si es posible, o unmount explícito.\n        setTimeout(() => {\n          if (rootDiv._reactRoot) {\n            rootDiv._reactRoot.unmount();\n            rootDiv._reactRoot = null;\n          }\n        }, 0);\n      }\n    });\n    return leafletMarker;\n  }, [showAssociatedIds, handleActivateCoords, handleSaveCoords, modoCorreccion]);\n\n  // --- Efecto Principal de Renderizado ---\n  useEffect(() => {\n    if (!map || !markers || markers.length === 0) return;\n\n    // Si estamos mostrando asociados, no refrescamos todo (a menos que cambien los filtros drásticamente, \n    // pero aquí asumimos que si 'markers' cambia, reseteamos vista).\n    // Para simplificar: si markers cambia, reseteamos todo.\n\n    clearCompetenciaMarkers();\n    clearPolylines();\n    setShowingAssociated(false);\n    setActiveMercadoPbl(null);\n    Object.values(markersRef.current).forEach(marker => {\n      try {\n        if (map && map.hasLayer(marker)) map.removeLayer(marker);\n      } catch (e) {}\n    });\n    markersRef.current = {};\n    clearGuerraMarkers();\n    markers.forEach(marker => {\n      const leafletMarker = createMarkerWithPopup(marker, markersForMercado || markers, 'primary');\n      if (leafletMarker) {\n        map.addLayer(leafletMarker);\n        markersRef.current[marker.id] = leafletMarker;\n        addGuerraMarker(marker);\n      }\n    });\n    if (markers.length === 1 && markersRef.current[markers[0].id]) {\n      markersRef.current[markers[0].id].openPopup();\n    }\n  }, [map, markers, markersForMercado, selectedRegion, clearCompetenciaMarkers, clearPolylines, clearGuerraMarkers, createMarkerWithPopup]);\n\n  // --- Efecto para Click en Mapa (Corrección Coordenadas) ---\n  useEffect(() => {\n    if (!map || !modoCorreccion) return;\n    const handleMapClick = e => {\n      const {\n        lat,\n        lng\n      } = e.latlng;\n      setModoCorreccion(prev => ({\n        ...prev,\n        lat,\n        lng\n      }));\n\n      // Actualizar UI del popup si está abierto?\n      // Como el popup se renderiza con 'modoCorreccion' como prop, \n      // necesitamos que se re-renderice.\n      // Al cambiar el estado 'modoCorreccion', el componente IconMarkersLayer se re-renderiza.\n      // Pero los popups ya abiertos son árboles de React independientes montados en nodos DOM.\n      // NO se actualizarán automáticamente con las nuevas props porque createMarkerWithPopup se recrea\n      // pero los popups ya montados no reciben las nuevas props a menos que los actualicemos explícitamente.\n\n      // SOLUCIÓN: Cerrar y abrir popup es brusco.\n      // Mejor: Usar un Context o un Store simple, o forzar update.\n      // Dado que 'createMarkerWithPopup' depende de 'modoCorreccion', \n      // cuando 'modoCorreccion' cambia, la función cambia.\n      // Pero los markers ya están en el mapa.\n\n      // Para esta refactorización rápida, podemos aceptar que el usuario cierre y abra, \n      // O intentar actualizar el popup activo.\n      // Lo más simple y robusto en React-Leaflet \"vanilla\" es difícil.\n      // Sin embargo, como MapPopup es hijo de IconMarkersLayer (indirectamente), \n      // NO lo es. Es un árbol nuevo.\n\n      // TRUCO: Disparar un evento custom que MapPopup escuche, o usar un ref mutable.\n      // O simplemente re-renderizar el contenido del popup activo.\n\n      // Vamos a iterar sobre los popups abiertos y re-renderizarlos.\n      map.eachLayer(layer => {\n        if (layer.getPopup && layer.getPopup() && layer.getPopup().isOpen()) {\n          const markerId = Object.keys(markersRef.current).find(key => markersRef.current[key] === layer);\n          if (markerId) {\n            const marker = markers.find(m => m.id === markerId) || (markersForMercado || []).find(m => m.id === markerId);\n            if (marker) {\n              const rootDiv = document.getElementById('popup-root-' + marker.id);\n              if (rootDiv && rootDiv._reactRoot) {\n                rootDiv._reactRoot.render(/*#__PURE__*/_jsxDEV(MapPopup, {\n                  marker: marker,\n                  allMarkers: markersForMercado || markers,\n                  onShowAssociated: showAssociatedIds,\n                  onActivateCoords: handleActivateCoords,\n                  onSaveCoords: handleSaveCoords,\n                  modoCorreccion: {\n                    ...modoCorreccion,\n                    lat,\n                    lng\n                  } // Pasamos el nuevo valor\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 377,\n                  columnNumber: 19\n                }, this));\n              }\n            }\n          }\n        }\n      });\n    };\n    map.on('click', handleMapClick);\n    return () => {\n      map.off('click', handleMapClick);\n    };\n  }, [map, modoCorreccion, markers, markersForMercado, showAssociatedIds, handleActivateCoords, handleSaveCoords]);\n  return null;\n};\n_s(IconMarkersLayer, \"Y0zNF6mWI6cHsn/i6aHnhgr7/7I=\", false, function () {\n  return [useMap];\n});\n_c = IconMarkersLayer;\nexport default IconMarkersLayer;\nvar _c;\n$RefreshReg$(_c, \"IconMarkersLayer\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","useMap","L","ReactDOM","createCustomIcon","guardarCoordenadaCorregida","MapPopup","jsxDEV","_jsxDEV","IconMarkersLayer","markers","markersForMercado","selectedRegion","baseCompData","_s","map","markersRef","guerraMarkersRef","competenciaMarkersRef","polylineRef","showingAssociated","setShowingAssociated","activeMercadoPbl","setActiveMercadoPbl","modoCorreccion","setModoCorreccion","clearCompetenciaMarkers","current","forEach","marker","hasLayer","removeLayer","e","clearPolylines","line","clearGuerraMarkers","Object","values","handleActivateCoords","getContainer","style","cursor","pbl","id","eds","marca","Marca","lat","lng","handleSaveCoords","coordenada","comuna","Comuna","lat_corregida","lon_corregida","m","error","console","showAssociatedIds","originalMarkerId","searchArray","length","leafletMarker","createMarkerWithPopup","addLayer","addGuerraMarker","associatedData","filter","item","String","trim","ids","originalMarker","find","associatedMarkers","includes","uniqueAssociatedMarkers","seenIds","Set","has","add","push","Guerra_Precio","guerraIcon","icon","iconUrl","process","env","PUBLIC_URL","iconSize","iconAnchor","className","guerraMarker","interactive","mainMarkersData","Marcador_Principal","mainMarker","markerWithCoords","mainLat","parseFloat","mainLng","isNaN","polyline","color","weight","opacity","dashArray","addTo","allMarkers","variant","popup","autoClose","closeOnClick","keepInView","autoPan","maxWidth","setContent","bindPopup","on","container","_contentNode","setTimeout","rootDiv","document","getElementById","_reactRoot","root","createRoot","render","onShowAssociated","onActivateCoords","onSaveCoords","fileName","_jsxFileName","lineNumber","columnNumber","unmount","openPopup","handleMapClick","latlng","prev","eachLayer","layer","getPopup","isOpen","markerId","keys","key","off","_c","$RefreshReg$"],"sources":["C:/Users/e08f/Desktop/Proyectos/Resumen/mapa-v2/src/components/IconMarkersLayer.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { useMap } from 'react-leaflet';\r\nimport L from 'leaflet';\r\nimport ReactDOM from 'react-dom/client';\r\nimport { createCustomIcon } from '../utils/iconHelpers';\r\nimport { guardarCoordenadaCorregida } from '../services/apiService';\r\nimport MapPopup from './MapPopup';\r\nimport '../styles/iconMarkersLayer.css';\r\n\r\nconst IconMarkersLayer = ({ markers, markersForMercado = null, selectedRegion, baseCompData = [] }) => {\r\n  const map = useMap();\r\n  const markersRef = useRef({});\r\n  const guerraMarkersRef = useRef({});\r\n  const competenciaMarkersRef = useRef([]);\r\n  const polylineRef = useRef([]);\r\n\r\n  const [showingAssociated, setShowingAssociated] = useState(false);\r\n  const [activeMercadoPbl, setActiveMercadoPbl] = useState(null);\r\n  const [modoCorreccion, setModoCorreccion] = useState(null);\r\n\r\n  // --- Helpers de limpieza ---\r\n  const clearCompetenciaMarkers = useCallback(() => {\r\n    competenciaMarkersRef.current.forEach(marker => {\r\n      try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n    });\r\n    competenciaMarkersRef.current = [];\r\n  }, [map]);\r\n\r\n  const clearPolylines = useCallback(() => {\r\n    polylineRef.current.forEach(line => {\r\n      try { if (map && map.hasLayer(line)) map.removeLayer(line); } catch (e) { }\r\n    });\r\n    polylineRef.current = [];\r\n  }, [map]);\r\n\r\n  const clearGuerraMarkers = useCallback(() => {\r\n    Object.values(guerraMarkersRef.current).forEach(marker => {\r\n      try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n    });\r\n    guerraMarkersRef.current = {};\r\n  }, [map]);\r\n\r\n  // --- Handlers ---\r\n  const handleActivateCoords = useCallback((marker) => {\r\n    if (map) map.getContainer().style.cursor = 'crosshair';\r\n    setModoCorreccion({\r\n      pbl: marker.pbl,\r\n      id: marker.id,\r\n      eds: marker.eds,\r\n      marca: marker.Marca,\r\n      lat: null,\r\n      lng: null\r\n    });\r\n  }, [map]);\r\n\r\n  const handleSaveCoords = useCallback(async (marker) => {\r\n    if (!modoCorreccion || !modoCorreccion.lat || !modoCorreccion.lng) return;\r\n\r\n    try {\r\n      const coordenada = {\r\n        id: marker.id || marker.pbl,\r\n        pbl: marker.pbl || marker.id,\r\n        eds: marker.eds || '',\r\n        marca: marker.Marca || '',\r\n        comuna: marker.Comuna || '',\r\n        lat_corregida: modoCorreccion.lat,\r\n        lon_corregida: modoCorreccion.lng\r\n      };\r\n      await guardarCoordenadaCorregida(coordenada);\r\n\r\n      // Actualizar marcador localmente\r\n      marker.lat = modoCorreccion.lat;\r\n      marker.lng = modoCorreccion.lng;\r\n\r\n      // Resetear modo corrección\r\n      setModoCorreccion(null);\r\n      if (map) map.getContainer().style.cursor = '';\r\n\r\n      // Re-renderizar marcadores (esto forzará un update del efecto principal)\r\n      // Nota: En una app real, deberíamos actualizar el estado 'markers' en el padre\r\n      // pero aquí simulamos el refresco limpiando y dejando que el efecto corra.\r\n      // Para simplificar, forzamos un re-render limpiando refs (el efecto lo notará si markers cambia, \r\n      // pero como mutamos el objeto, necesitamos forzar update o confiar en que el padre refresque).\r\n      // Aquí asumimos que el padre refrescará o que el efecto de abajo se encargará si cambiamos algo.\r\n      // Como mutamos 'marker', React no detecta cambio de prop 'markers' si es el mismo array.\r\n      // Forzamos limpieza manual y re-creación:\r\n      Object.values(markersRef.current).forEach(m => {\r\n        if (map.hasLayer(m)) map.removeLayer(m);\r\n      });\r\n      markersRef.current = {};\r\n      clearGuerraMarkers();\r\n\r\n      // Disparamos un evento custom o callback si fuera necesario, \r\n      // por ahora confiamos en que el usuario recargue o que el efecto se dispare si cambiamos algo de estado.\r\n      // Un truco es setear un estado dummy para forzar re-render, pero mejor dejemos que el flujo siga.\r\n\r\n    } catch (error) {\r\n      console.error(\"Error guardando coordenadas:\", error);\r\n    }\r\n  }, [modoCorreccion, map, clearGuerraMarkers]);\r\n\r\n\r\n  // --- Lógica de Mercado (Show Associated) ---\r\n  const showAssociatedIds = useCallback((pbl, lat, lng, originalMarkerId) => {\r\n    const searchArray = markersForMercado && markersForMercado.length > 0 ? markersForMercado : markers;\r\n\r\n    if (showingAssociated && activeMercadoPbl === pbl) {\r\n      // Toggle OFF\r\n      clearCompetenciaMarkers();\r\n      clearPolylines();\r\n      setShowingAssociated(false);\r\n      setActiveMercadoPbl(null);\r\n\r\n      // Restaurar marcadores originales\r\n      Object.values(markersRef.current).forEach(marker => {\r\n        try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n      });\r\n      markersRef.current = {};\r\n\r\n      // Re-crear todos\r\n      markers.forEach(marker => {\r\n        const leafletMarker = createMarkerWithPopup(marker, markersForMercado || markers, 'primary');\r\n        if (leafletMarker) {\r\n          map.addLayer(leafletMarker);\r\n          markersRef.current[marker.id] = leafletMarker;\r\n          addGuerraMarker(marker);\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Toggle ON (o cambio de PBL)\r\n    clearCompetenciaMarkers();\r\n    clearPolylines();\r\n\r\n    const associatedData = baseCompData.filter(item => String(item.pbl).trim() === String(pbl).trim());\r\n    if (associatedData.length === 0) return;\r\n\r\n    const ids = associatedData.map(item => item.id);\r\n\r\n    // Limpiar actuales\r\n    Object.values(markersRef.current).forEach(marker => {\r\n      try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n    });\r\n    markersRef.current = {};\r\n    clearGuerraMarkers();\r\n\r\n    // Mostrar original\r\n    const originalMarker = markers.find(m => m.id === originalMarkerId);\r\n    if (originalMarker) {\r\n      const leafletMarker = createMarkerWithPopup(originalMarker, markersForMercado || markers, 'primary');\r\n      if (leafletMarker) {\r\n        map.addLayer(leafletMarker);\r\n        markersRef.current[originalMarker.id] = leafletMarker;\r\n        addGuerraMarker(originalMarker);\r\n      }\r\n    }\r\n\r\n    // Mostrar competencia\r\n    const associatedMarkers = searchArray.filter(item => ids.includes(item.id));\r\n    const uniqueAssociatedMarkers = [];\r\n    const seenIds = new Set();\r\n    associatedMarkers.forEach(marker => {\r\n      if (!seenIds.has(marker.id)) {\r\n        seenIds.add(marker.id);\r\n        uniqueAssociatedMarkers.push(marker);\r\n      }\r\n    });\r\n\r\n    uniqueAssociatedMarkers.forEach(marker => {\r\n      const leafletMarker = createMarkerWithPopup(marker, markersForMercado || baseCompData, 'secondary');\r\n      if (leafletMarker) {\r\n        map.addLayer(leafletMarker);\r\n        competenciaMarkersRef.current.push(leafletMarker);\r\n        if (marker.Guerra_Precio === 'Si') {\r\n          // Guerra marker logic for secondary\r\n          const guerraIcon = L.icon({\r\n            iconUrl: `${process.env.PUBLIC_URL}/iconos/calavera.jpg`,\r\n            iconSize: [15, 15],\r\n            iconAnchor: [7.5, 7.5],\r\n            className: 'icono-guerra'\r\n          });\r\n          const guerraMarker = L.marker([marker.lat, marker.lng], { icon: guerraIcon, interactive: false });\r\n          map.addLayer(guerraMarker);\r\n          // No lo guardamos en ref global para no borrarlo accidentalmente con clearGuerraMarkers si solo queremos borrar los principales, \r\n          // aunque aquí borramos todo al cambiar de vista.\r\n          // Para simplificar, los agregamos a competenciaMarkersRef si queremos limpiarlos con eso, o los dejamos sueltos (pero hay que limpiarlos).\r\n          // Mejor los metemos en competenciaMarkersRef también (aunque sean markers distintos).\r\n          competenciaMarkersRef.current.push(guerraMarker);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Polylines\r\n    const mainMarkersData = associatedData.filter(m => m.Marcador_Principal === 'Si');\r\n    mainMarkersData.forEach(mainMarker => {\r\n      const markerWithCoords = searchArray.find(m => m.id === mainMarker.id);\r\n      if (!markerWithCoords) return;\r\n      const mainLat = parseFloat(markerWithCoords.lat);\r\n      const mainLng = parseFloat(markerWithCoords.lng);\r\n      if (isNaN(mainLat) || isNaN(mainLng)) return;\r\n\r\n      const polyline = L.polyline(\r\n        [[parseFloat(lat), parseFloat(lng)], [mainLat, mainLng]],\r\n        { color: '#FF6B6B', weight: 3, opacity: 0.8, dashArray: '5, 5' }\r\n      ).addTo(map);\r\n      polylineRef.current.push(polyline);\r\n    });\r\n\r\n    setShowingAssociated(true);\r\n    setActiveMercadoPbl(pbl);\r\n\r\n  }, [baseCompData, markers, markersForMercado, map, showingAssociated, activeMercadoPbl, clearCompetenciaMarkers, clearPolylines, clearGuerraMarkers]); // createMarkerWithPopup is defined below, using ref to avoid circular dep or hoisting issues if possible, or just define it before.\r\n\r\n  // Helper para Guerra Marker\r\n  const addGuerraMarker = (marker) => {\r\n    if (marker.Guerra_Precio === 'Si') {\r\n      const guerraIcon = L.icon({\r\n        iconUrl: `${process.env.PUBLIC_URL}/iconos/calavera.jpg`,\r\n        iconSize: [15, 15],\r\n        iconAnchor: [7.5, 7.5],\r\n        className: 'icono-guerra'\r\n      });\r\n      const guerraMarker = L.marker([marker.lat, marker.lng], { icon: guerraIcon, interactive: false });\r\n      map.addLayer(guerraMarker);\r\n      guerraMarkersRef.current[marker.id] = guerraMarker;\r\n    }\r\n  };\r\n\r\n  // --- Crear Marcador con Popup React ---\r\n  const createMarkerWithPopup = useCallback((marker, allMarkers, variant = 'primary') => {\r\n    const lat = parseFloat(marker.lat);\r\n    const lng = parseFloat(marker.lng);\r\n    if (isNaN(lat) || isNaN(lng)) return null;\r\n\r\n    const iconUrl = createCustomIcon(marker.Marca);\r\n    const leafletMarker = L.marker([lat, lng], { icon: iconUrl });\r\n\r\n    // Popup vacío inicial\r\n    const popup = L.popup({\r\n      autoClose: false,\r\n      closeOnClick: false,\r\n      keepInView: true,\r\n      autoPan: false,\r\n      maxWidth: 450,\r\n      className: 'custom-popup'\r\n    }).setContent('<div id=\"popup-root-' + marker.id + '\"></div>');\r\n\r\n    leafletMarker.bindPopup(popup);\r\n\r\n    // Renderizar React en el Popup al abrir\r\n    leafletMarker.on('popupopen', (e) => {\r\n      const container = e.popup._contentNode; // o _container\r\n      // Buscar el div root que pusimos\r\n      // Nota: Leaflet a veces envuelve el contenido.\r\n      // Mejor estrategia: usar el contenido del popup como container.\r\n\r\n      // Esperamos un tick para asegurar que el DOM existe\r\n      setTimeout(() => {\r\n        const rootDiv = document.getElementById('popup-root-' + marker.id);\r\n        if (rootDiv && !rootDiv._reactRoot) {\r\n          const root = ReactDOM.createRoot(rootDiv);\r\n          rootDiv._reactRoot = root;\r\n          root.render(\r\n            <MapPopup\r\n              marker={marker}\r\n              allMarkers={allMarkers}\r\n              onShowAssociated={showAssociatedIds}\r\n              onActivateCoords={handleActivateCoords}\r\n              onSaveCoords={handleSaveCoords}\r\n              modoCorreccion={modoCorreccion}\r\n            />\r\n          );\r\n        }\r\n      }, 0);\r\n    });\r\n\r\n    leafletMarker.on('popupclose', (e) => {\r\n      const rootDiv = document.getElementById('popup-root-' + marker.id);\r\n      if (rootDiv && rootDiv._reactRoot) {\r\n        // Desmontar para evitar leaks\r\n        // rootDiv._reactRoot.unmount(); // A veces da problemas si se cierra muy rápido, pero es buena práctica.\r\n        // Dejamos que React maneje la limpieza si es posible, o unmount explícito.\r\n        setTimeout(() => {\r\n          if (rootDiv._reactRoot) {\r\n            rootDiv._reactRoot.unmount();\r\n            rootDiv._reactRoot = null;\r\n          }\r\n        }, 0);\r\n      }\r\n    });\r\n\r\n    return leafletMarker;\r\n  }, [showAssociatedIds, handleActivateCoords, handleSaveCoords, modoCorreccion]);\r\n\r\n\r\n  // --- Efecto Principal de Renderizado ---\r\n  useEffect(() => {\r\n    if (!map || !markers || markers.length === 0) return;\r\n\r\n    // Si estamos mostrando asociados, no refrescamos todo (a menos que cambien los filtros drásticamente, \r\n    // pero aquí asumimos que si 'markers' cambia, reseteamos vista).\r\n    // Para simplificar: si markers cambia, reseteamos todo.\r\n\r\n    clearCompetenciaMarkers();\r\n    clearPolylines();\r\n    setShowingAssociated(false);\r\n    setActiveMercadoPbl(null);\r\n\r\n    Object.values(markersRef.current).forEach(marker => {\r\n      try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n    });\r\n    markersRef.current = {};\r\n    clearGuerraMarkers();\r\n\r\n    markers.forEach(marker => {\r\n      const leafletMarker = createMarkerWithPopup(\r\n        marker,\r\n        markersForMercado || markers,\r\n        'primary'\r\n      );\r\n      if (leafletMarker) {\r\n        map.addLayer(leafletMarker);\r\n        markersRef.current[marker.id] = leafletMarker;\r\n        addGuerraMarker(marker);\r\n      }\r\n    });\r\n\r\n    if (markers.length === 1 && markersRef.current[markers[0].id]) {\r\n      markersRef.current[markers[0].id].openPopup();\r\n    }\r\n\r\n  }, [map, markers, markersForMercado, selectedRegion, clearCompetenciaMarkers, clearPolylines, clearGuerraMarkers, createMarkerWithPopup]);\r\n\r\n\r\n  // --- Efecto para Click en Mapa (Corrección Coordenadas) ---\r\n  useEffect(() => {\r\n    if (!map || !modoCorreccion) return;\r\n\r\n    const handleMapClick = (e) => {\r\n      const { lat, lng } = e.latlng;\r\n      setModoCorreccion(prev => ({ ...prev, lat, lng }));\r\n\r\n      // Actualizar UI del popup si está abierto?\r\n      // Como el popup se renderiza con 'modoCorreccion' como prop, \r\n      // necesitamos que se re-renderice.\r\n      // Al cambiar el estado 'modoCorreccion', el componente IconMarkersLayer se re-renderiza.\r\n      // Pero los popups ya abiertos son árboles de React independientes montados en nodos DOM.\r\n      // NO se actualizarán automáticamente con las nuevas props porque createMarkerWithPopup se recrea\r\n      // pero los popups ya montados no reciben las nuevas props a menos que los actualicemos explícitamente.\r\n\r\n      // SOLUCIÓN: Cerrar y abrir popup es brusco.\r\n      // Mejor: Usar un Context o un Store simple, o forzar update.\r\n      // Dado que 'createMarkerWithPopup' depende de 'modoCorreccion', \r\n      // cuando 'modoCorreccion' cambia, la función cambia.\r\n      // Pero los markers ya están en el mapa.\r\n\r\n      // Para esta refactorización rápida, podemos aceptar que el usuario cierre y abra, \r\n      // O intentar actualizar el popup activo.\r\n      // Lo más simple y robusto en React-Leaflet \"vanilla\" es difícil.\r\n      // Sin embargo, como MapPopup es hijo de IconMarkersLayer (indirectamente), \r\n      // NO lo es. Es un árbol nuevo.\r\n\r\n      // TRUCO: Disparar un evento custom que MapPopup escuche, o usar un ref mutable.\r\n      // O simplemente re-renderizar el contenido del popup activo.\r\n\r\n      // Vamos a iterar sobre los popups abiertos y re-renderizarlos.\r\n      map.eachLayer(layer => {\r\n        if (layer.getPopup && layer.getPopup() && layer.getPopup().isOpen()) {\r\n          const markerId = Object.keys(markersRef.current).find(key => markersRef.current[key] === layer);\r\n          if (markerId) {\r\n            const marker = markers.find(m => m.id === markerId) || (markersForMercado || []).find(m => m.id === markerId);\r\n            if (marker) {\r\n              const rootDiv = document.getElementById('popup-root-' + marker.id);\r\n              if (rootDiv && rootDiv._reactRoot) {\r\n                rootDiv._reactRoot.render(\r\n                  <MapPopup\r\n                    marker={marker}\r\n                    allMarkers={markersForMercado || markers}\r\n                    onShowAssociated={showAssociatedIds}\r\n                    onActivateCoords={handleActivateCoords}\r\n                    onSaveCoords={handleSaveCoords}\r\n                    modoCorreccion={{ ...modoCorreccion, lat, lng }} // Pasamos el nuevo valor\r\n                  />\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    map.on('click', handleMapClick);\r\n    return () => { map.off('click', handleMapClick); };\r\n  }, [map, modoCorreccion, markers, markersForMercado, showAssociatedIds, handleActivateCoords, handleSaveCoords]);\r\n\r\n\r\n  return null;\r\n};\r\n\r\nexport default IconMarkersLayer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}