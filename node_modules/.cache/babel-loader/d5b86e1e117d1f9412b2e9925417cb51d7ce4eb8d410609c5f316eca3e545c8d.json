{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\e08f\\\\Desktop\\\\Proyectos\\\\Resumen\\\\mapa-v2\\\\src\\\\components\\\\IconMarkersLayer.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport ReactDOM from 'react-dom/client';\nimport { createCustomIcon } from '../utils/iconHelpers';\nimport { guardarCoordenadaCorregida } from '../services/apiService';\nimport MapPopup from './MapPopup';\nimport '../styles/iconMarkersLayer.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst IconMarkersLayer = ({\n  markers,\n  markersForMercado = null,\n  selectedRegion,\n  baseCompData = []\n}) => {\n  _s();\n  const map = useMap();\n  const markersRef = useRef({});\n  const guerraMarkersRef = useRef({});\n  const competenciaMarkersRef = useRef([]);\n  const polylineRef = useRef([]);\n  const [showingAssociated, setShowingAssociated] = useState(false);\n  const [activeMercadoPbl, setActiveMercadoPbl] = useState(null);\n  const [modoCorreccion, setModoCorreccion] = useState(null);\n\n  // --- Helpers de UI (Draggable & Resize) ---\n  const makeDraggable = useCallback(popup => {\n    if (!map || !popup || !popup._container) return;\n    try {\n      const pos = map.latLngToLayerPoint(popup.getLatLng());\n      L.DomUtil.setPosition(popup._wrapper.parentNode, pos);\n      const draggable = new L.Draggable(popup._container, popup._wrapper);\n      draggable.enable();\n    } catch (error) {\n      console.error('Error draggable:', error);\n    }\n  }, [map]);\n  const crearGripEnWrapper = useCallback(popupContainer => {\n    const wrapper = popupContainer.querySelector('.leaflet-popup-content-wrapper');\n    const content = popupContainer.querySelector('.leaflet-popup-content');\n    if (!wrapper || !content) return;\n    content === null || content === void 0 ? void 0 : content.querySelectorAll('.popup-resize-grip').forEach(n => n.remove());\n    const handleWheel = e => {\n      e.preventDefault();\n      const scrollSpeed = 0.5;\n      const scrollAmount = e.deltaY * scrollSpeed;\n      content.scrollTop += scrollAmount;\n    };\n    content.addEventListener('wheel', handleWheel, {\n      passive: false\n    });\n    let grip = wrapper.querySelector('.popup-resize-grip');\n    if (!grip) {\n      grip = document.createElement('div');\n      grip.className = 'popup-resize-grip';\n      wrapper.appendChild(grip);\n      let isResizing = false;\n      const startResize = e => {\n        isResizing = true;\n        document.body.classList.add('is-resizing-popup');\n        document.body.style.cursor = 'nwse-resize';\n        document.body.style.userSelect = 'none';\n        e.preventDefault();\n        e.stopPropagation();\n      };\n      const doResize = e => {\n        if (!isResizing) return;\n        const clientX = e.clientX || e.touches && e.touches[0].clientX;\n        const clientY = e.clientY || e.touches && e.touches[0].clientY;\n        const gripRect = grip.getBoundingClientRect();\n        const gripCenterX = gripRect.left + gripRect.width / 2;\n        const gripCenterY = gripRect.top + gripRect.height / 2;\n        const deltaX = clientX - gripCenterX;\n        const deltaY = clientY - gripCenterY;\n        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {\n          const currentRect = content.getBoundingClientRect();\n          const newWidth = Math.max(240, currentRect.width + deltaX);\n          const newHeight = Math.max(180, currentRect.height + deltaY);\n          content.style.width = newWidth + 'px';\n          content.style.height = newHeight + 'px';\n        }\n        e.preventDefault();\n      };\n      const stopResize = () => {\n        if (!isResizing) return;\n        isResizing = false;\n        document.body.classList.remove('is-resizing-popup');\n        document.body.style.cursor = '';\n        document.body.style.userSelect = '';\n      };\n      grip.addEventListener('mousedown', startResize);\n      document.addEventListener('mousemove', doResize);\n      document.addEventListener('mouseup', stopResize);\n      grip.addEventListener('touchstart', startResize, {\n        passive: false\n      });\n      document.addEventListener('touchmove', doResize, {\n        passive: false\n      });\n      document.addEventListener('touchend', stopResize);\n      const cleanup = () => {\n        content.removeEventListener('wheel', handleWheel);\n        document.removeEventListener('mousemove', doResize);\n        document.removeEventListener('mouseup', stopResize);\n        document.removeEventListener('touchmove', doResize);\n        document.removeEventListener('touchend', stopResize);\n        document.body.classList.remove('is-resizing-popup');\n      };\n      grip._cleanup = cleanup;\n    }\n  }, []);\n\n  // --- Helpers de limpieza ---\n  const clearCompetenciaMarkers = useCallback(() => {\n    competenciaMarkersRef.current.forEach(marker => {\n      try {\n        if (map && map.hasLayer(marker)) map.removeLayer(marker);\n      } catch (e) {}\n    });\n    competenciaMarkersRef.current = [];\n  }, [map]);\n  const clearPolylines = useCallback(() => {\n    polylineRef.current.forEach(line => {\n      try {\n        if (map && map.hasLayer(line)) map.removeLayer(line);\n      } catch (e) {}\n    });\n    polylineRef.current = [];\n  }, [map]);\n  const clearGuerraMarkers = useCallback(() => {\n    Object.values(guerraMarkersRef.current).forEach(marker => {\n      try {\n        if (map && map.hasLayer(marker)) map.removeLayer(marker);\n      } catch (e) {}\n    });\n    guerraMarkersRef.current = {};\n  }, [map]);\n\n  // --- Handlers ---\n  const handleActivateCoords = useCallback(marker => {\n    if (map) map.getContainer().style.cursor = 'crosshair';\n    setModoCorreccion({\n      pbl: marker.pbl,\n      id: marker.id,\n      eds: marker.eds,\n      marca: marker.Marca,\n      lat: null,\n      lng: null\n    });\n  }, [map]);\n  const handleSaveCoords = useCallback(async marker => {\n    if (!modoCorreccion || !modoCorreccion.lat || !modoCorreccion.lng) return;\n    try {\n      const coordenada = {\n        id: marker.id || marker.pbl,\n        pbl: marker.pbl || marker.id,\n        eds: marker.eds || '',\n        marca: marker.Marca || '',\n        comuna: marker.Comuna || '',\n        lat_corregida: modoCorreccion.lat,\n        lon_corregida: modoCorreccion.lng\n      };\n      await guardarCoordenadaCorregida(coordenada);\n\n      // Actualizar marcador localmente\n      marker.lat = modoCorreccion.lat;\n      marker.lng = modoCorreccion.lng;\n\n      // Resetear modo corrección\n      setModoCorreccion(null);\n      if (map) map.getContainer().style.cursor = '';\n\n      // Re-renderizar marcadores (esto forzará un update del efecto principal)\n      // Nota: En una app real, deberíamos actualizar el estado 'markers' en el padre\n      // pero aquí simulamos el refresco limpiando y dejando que el efecto corra.\n      // Para simplificar, forzamos un re-render limpiando refs (el efecto lo notará si markers cambia, \n      // pero como mutamos el objeto, necesitamos forzar update o confiar en que el padre refresque).\n      // Aquí asumimos que el padre refrescará o que el efecto de abajo se encargará si cambiamos algo.\n      // Como mutamos 'marker', React no detecta cambio de prop 'markers' si es el mismo array.\n      // Forzamos limpieza manual y re-creación:\n      Object.values(markersRef.current).forEach(m => {\n        if (map.hasLayer(m)) map.removeLayer(m);\n      });\n      markersRef.current = {};\n      clearGuerraMarkers();\n\n      // Disparamos un evento custom o callback si fuera necesario, \n      // por ahora confiamos en que el usuario recargue o que el efecto se dispare si cambiamos algo de estado.\n      // Un truco es setear un estado dummy para forzar re-render, pero mejor dejemos que el flujo siga.\n    } catch (error) {\n      console.error(\"Error guardando coordenadas:\", error);\n    }\n  }, [modoCorreccion, map, clearGuerraMarkers]);\n\n  // --- Lógica de Mercado (Show Associated) ---\n  const showAssociatedIds = useCallback((pbl, lat, lng, originalMarkerId) => {\n    const searchArray = markersForMercado && markersForMercado.length > 0 ? markersForMercado : markers;\n    if (showingAssociated && activeMercadoPbl === pbl) {\n      // Toggle OFF\n      clearCompetenciaMarkers();\n      clearPolylines();\n      setShowingAssociated(false);\n      setActiveMercadoPbl(null);\n\n      // Restaurar marcadores originales\n      Object.values(markersRef.current).forEach(marker => {\n        try {\n          if (map && map.hasLayer(marker)) map.removeLayer(marker);\n        } catch (e) {}\n      });\n      markersRef.current = {};\n\n      // Re-crear todos\n      markers.forEach(marker => {\n        const leafletMarker = createMarkerWithPopup(marker, markersForMercado || markers, 'primary');\n        if (leafletMarker) {\n          map.addLayer(leafletMarker);\n          markersRef.current[marker.id] = leafletMarker;\n          addGuerraMarker(marker);\n        }\n      });\n      return;\n    }\n\n    // Toggle ON (o cambio de PBL)\n    clearCompetenciaMarkers();\n    clearPolylines();\n    const associatedData = baseCompData.filter(item => String(item.pbl).trim() === String(pbl).trim());\n    if (associatedData.length === 0) return;\n    const ids = associatedData.map(item => item.id);\n\n    // Limpiar actuales\n    Object.values(markersRef.current).forEach(marker => {\n      try {\n        if (map && map.hasLayer(marker)) map.removeLayer(marker);\n      } catch (e) {}\n    });\n    markersRef.current = {};\n    clearGuerraMarkers();\n\n    // Mostrar original\n    const originalMarker = markers.find(m => m.id === originalMarkerId);\n    if (originalMarker) {\n      const leafletMarker = createMarkerWithPopup(originalMarker, markersForMercado || markers, 'primary');\n      if (leafletMarker) {\n        map.addLayer(leafletMarker);\n        markersRef.current[originalMarker.id] = leafletMarker;\n        addGuerraMarker(originalMarker);\n      }\n    }\n\n    // Mostrar competencia\n    const associatedMarkers = searchArray.filter(item => ids.includes(item.id));\n    const uniqueAssociatedMarkers = [];\n    const seenIds = new Set();\n    associatedMarkers.forEach(marker => {\n      if (!seenIds.has(marker.id)) {\n        seenIds.add(marker.id);\n        uniqueAssociatedMarkers.push(marker);\n      }\n    });\n    uniqueAssociatedMarkers.forEach(marker => {\n      const leafletMarker = createMarkerWithPopup(marker, markersForMercado || baseCompData, 'secondary');\n      if (leafletMarker) {\n        map.addLayer(leafletMarker);\n        competenciaMarkersRef.current.push(leafletMarker);\n        if (marker.Guerra_Precio === 'Si') {\n          // Guerra marker logic for secondary\n          const guerraIcon = L.icon({\n            iconUrl: `${process.env.PUBLIC_URL}/iconos/calavera.jpg`,\n            iconSize: [15, 15],\n            iconAnchor: [7.5, 7.5],\n            className: 'icono-guerra'\n          });\n          const guerraMarker = L.marker([marker.lat, marker.lng], {\n            icon: guerraIcon,\n            interactive: false\n          });\n          map.addLayer(guerraMarker);\n          // No lo guardamos en ref global para no borrarlo accidentalmente con clearGuerraMarkers si solo queremos borrar los principales, \n          // aunque aquí borramos todo al cambiar de vista.\n          // Para simplificar, los agregamos a competenciaMarkersRef si queremos limpiarlos con eso, o los dejamos sueltos (pero hay que limpiarlos).\n          // Mejor los metemos en competenciaMarkersRef también (aunque sean markers distintos).\n          competenciaMarkersRef.current.push(guerraMarker);\n        }\n      }\n    });\n\n    // Polylines\n    const mainMarkersData = associatedData.filter(m => m.Marcador_Principal === 'Si');\n    mainMarkersData.forEach(mainMarker => {\n      const markerWithCoords = searchArray.find(m => m.id === mainMarker.id);\n      if (!markerWithCoords) return;\n      const mainLat = parseFloat(markerWithCoords.lat);\n      const mainLng = parseFloat(markerWithCoords.lng);\n      if (isNaN(mainLat) || isNaN(mainLng)) return;\n      const polyline = L.polyline([[parseFloat(lat), parseFloat(lng)], [mainLat, mainLng]], {\n        color: '#FF6B6B',\n        weight: 3,\n        opacity: 0.8,\n        dashArray: '5, 5'\n      }).addTo(map);\n      polylineRef.current.push(polyline);\n    });\n    setShowingAssociated(true);\n    setActiveMercadoPbl(pbl);\n  }, [baseCompData, markers, markersForMercado, map, showingAssociated, activeMercadoPbl, clearCompetenciaMarkers, clearPolylines, clearGuerraMarkers]); // createMarkerWithPopup is defined below, using ref to avoid circular dep or hoisting issues if possible, or just define it before.\n\n  // Helper para Guerra Marker\n  const addGuerraMarker = marker => {\n    if (marker.Guerra_Precio === 'Si') {\n      const guerraIcon = L.icon({\n        iconUrl: `${process.env.PUBLIC_URL}/iconos/calavera.jpg`,\n        iconSize: [15, 15],\n        iconAnchor: [7.5, 7.5],\n        className: 'icono-guerra'\n      });\n      const guerraMarker = L.marker([marker.lat, marker.lng], {\n        icon: guerraIcon,\n        interactive: false\n      });\n      map.addLayer(guerraMarker);\n      guerraMarkersRef.current[marker.id] = guerraMarker;\n    }\n  };\n\n  // --- Crear Marcador con Popup React ---\n  const createMarkerWithPopup = useCallback((marker, allMarkers, variant = 'primary') => {\n    const lat = parseFloat(marker.lat);\n    const lng = parseFloat(marker.lng);\n    if (isNaN(lat) || isNaN(lng)) return null;\n    const iconUrl = createCustomIcon(marker.Marca);\n    const leafletMarker = L.marker([lat, lng], {\n      icon: iconUrl\n    });\n\n    // Popup vacío inicial\n    const popup = L.popup({\n      autoClose: false,\n      closeOnClick: false,\n      keepInView: true,\n      autoPan: false,\n      maxWidth: 450,\n      className: 'custom-popup'\n    }).setContent('<div id=\"popup-root-' + marker.id + '\"></div>');\n    leafletMarker.bindPopup(popup);\n\n    // Renderizar React en el Popup al abrir\n    leafletMarker.on('popupopen', e => {\n      makeDraggable(popup);\n      const container = e.popup._contentNode; // o _container\n      const wrapperContainer = e.popup._container;\n      if (wrapperContainer) {\n        crearGripEnWrapper(wrapperContainer);\n      }\n      // Buscar el div root que pusimos\n      // Buscar el div root que pusimos\n      // Nota: Leaflet a veces envuelve el contenido.\n      // Mejor estrategia: usar el contenido del popup como container.\n\n      // Esperamos un tick para asegurar que el DOM existe\n      setTimeout(() => {\n        const rootDiv = document.getElementById('popup-root-' + marker.id);\n        if (rootDiv && !rootDiv._reactRoot) {\n          const root = ReactDOM.createRoot(rootDiv);\n          rootDiv._reactRoot = root;\n          root.render(/*#__PURE__*/_jsxDEV(MapPopup, {\n            marker: marker,\n            allMarkers: allMarkers,\n            onShowAssociated: showAssociatedIds,\n            onActivateCoords: handleActivateCoords,\n            onSaveCoords: handleSaveCoords,\n            onSaveCoords: handleSaveCoords,\n            modoCorreccion: modoCorreccion,\n            variant: variant\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 371,\n            columnNumber: 13\n          }, this));\n        }\n      }, 0);\n    });\n    leafletMarker.on('popupclose', e => {\n      var _e$popup;\n      const container = (_e$popup = e.popup) === null || _e$popup === void 0 ? void 0 : _e$popup._container;\n      if (container) {\n        const wrapper = container.querySelector('.leaflet-popup-content-wrapper');\n        const grip = wrapper === null || wrapper === void 0 ? void 0 : wrapper.querySelector('.popup-resize-grip');\n        if (grip && grip._cleanup) {\n          grip._cleanup();\n        }\n      }\n      const rootDiv = document.getElementById('popup-root-' + marker.id);\n      if (rootDiv && rootDiv._reactRoot) {\n        // Desmontar para evitar leaks\n        // rootDiv._reactRoot.unmount(); // A veces da problemas si se cierra muy rápido, pero es buena práctica.\n        // Dejamos que React maneje la limpieza si es posible, o unmount explícito.\n        setTimeout(() => {\n          if (rootDiv._reactRoot) {\n            rootDiv._reactRoot.unmount();\n            rootDiv._reactRoot = null;\n          }\n        }, 0);\n      }\n    });\n    return leafletMarker;\n  }, [showAssociatedIds, handleActivateCoords, handleSaveCoords, modoCorreccion, makeDraggable, crearGripEnWrapper]);\n\n  // --- Efecto Principal de Renderizado ---\n  useEffect(() => {\n    if (!map || !markers || markers.length === 0) return;\n\n    // Si estamos mostrando asociados, no refrescamos todo (a menos que cambien los filtros drásticamente, \n    // pero aquí asumimos que si 'markers' cambia, reseteamos vista).\n    // Para simplificar: si markers cambia, reseteamos todo.\n\n    clearCompetenciaMarkers();\n    clearPolylines();\n    setShowingAssociated(false);\n    setActiveMercadoPbl(null);\n    Object.values(markersRef.current).forEach(marker => {\n      try {\n        if (map && map.hasLayer(marker)) map.removeLayer(marker);\n      } catch (e) {}\n    });\n    markersRef.current = {};\n    clearGuerraMarkers();\n    markers.forEach(marker => {\n      const leafletMarker = createMarkerWithPopup(marker, markersForMercado || markers, 'primary');\n      if (leafletMarker) {\n        map.addLayer(leafletMarker);\n        markersRef.current[marker.id] = leafletMarker;\n        addGuerraMarker(marker);\n      }\n    });\n    if (markers.length === 1 && markersRef.current[markers[0].id]) {\n      markersRef.current[markers[0].id].openPopup();\n    }\n  }, [map, markers, markersForMercado, selectedRegion, clearCompetenciaMarkers, clearPolylines, clearGuerraMarkers, createMarkerWithPopup]);\n\n  // --- Efecto para Click en Mapa (Corrección Coordenadas) ---\n  useEffect(() => {\n    if (!map || !modoCorreccion) return;\n    const handleMapClick = e => {\n      const {\n        lat,\n        lng\n      } = e.latlng;\n      setModoCorreccion(prev => ({\n        ...prev,\n        lat,\n        lng\n      }));\n\n      // Actualizar UI del popup si está abierto?\n      // Como el popup se renderiza con 'modoCorreccion' como prop, \n      // necesitamos que se re-renderice.\n      // Al cambiar el estado 'modoCorreccion', el componente IconMarkersLayer se re-renderiza.\n      // Pero los popups ya abiertos son árboles de React independientes montados en nodos DOM.\n      // NO se actualizarán automáticamente con las nuevas props porque createMarkerWithPopup se recrea\n      // pero los popups ya montados no reciben las nuevas props a menos que los actualicemos explícitamente.\n\n      // SOLUCIÓN: Cerrar y abrir popup es brusco.\n      // Mejor: Usar un Context o un Store simple, o forzar update.\n      // Dado que 'createMarkerWithPopup' depende de 'modoCorreccion', \n      // cuando 'modoCorreccion' cambia, la función cambia.\n      // Pero los markers ya están en el mapa.\n\n      // Para esta refactorización rápida, podemos aceptar que el usuario cierre y abra, \n      // O intentar actualizar el popup activo.\n      // Lo más simple y robusto en React-Leaflet \"vanilla\" es difícil.\n      // Sin embargo, como MapPopup es hijo de IconMarkersLayer (indirectamente), \n      // NO lo es. Es un árbol nuevo.\n\n      // TRUCO: Disparar un evento custom que MapPopup escuche, o usar un ref mutable.\n      // O simplemente re-renderizar el contenido del popup activo.\n\n      // Vamos a iterar sobre los popups abiertos y re-renderizarlos.\n      map.eachLayer(layer => {\n        if (layer.getPopup && layer.getPopup() && layer.getPopup().isOpen()) {\n          const markerId = Object.keys(markersRef.current).find(key => markersRef.current[key] === layer);\n          if (markerId) {\n            const marker = markers.find(m => m.id === markerId) || (markersForMercado || []).find(m => m.id === markerId);\n            if (marker) {\n              const rootDiv = document.getElementById('popup-root-' + marker.id);\n              if (rootDiv && rootDiv._reactRoot) {\n                rootDiv._reactRoot.render(/*#__PURE__*/_jsxDEV(MapPopup, {\n                  marker: marker,\n                  allMarkers: markersForMercado || markers,\n                  onShowAssociated: showAssociatedIds,\n                  onActivateCoords: handleActivateCoords,\n                  onSaveCoords: handleSaveCoords,\n                  onSaveCoords: handleSaveCoords,\n                  modoCorreccion: {\n                    ...modoCorreccion,\n                    lat,\n                    lng\n                  } // Pasamos el nuevo valor\n                  ,\n                  variant: markersForMercado && markersForMercado.includes(marker) ? 'secondary' : 'primary' // Aproximación, mejor pasar variant si pudiéramos\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 494,\n                  columnNumber: 19\n                }, this));\n              }\n            }\n          }\n        }\n      });\n    };\n    map.on('click', handleMapClick);\n    return () => {\n      map.off('click', handleMapClick);\n    };\n  }, [map, modoCorreccion, markers, markersForMercado, showAssociatedIds, handleActivateCoords, handleSaveCoords]);\n  return null;\n};\n_s(IconMarkersLayer, \"RuHf1lEYX0g4E3TtPM/lOdLgGCo=\", false, function () {\n  return [useMap];\n});\n_c = IconMarkersLayer;\nexport default IconMarkersLayer;\nvar _c;\n$RefreshReg$(_c, \"IconMarkersLayer\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","useMap","L","ReactDOM","createCustomIcon","guardarCoordenadaCorregida","MapPopup","jsxDEV","_jsxDEV","IconMarkersLayer","markers","markersForMercado","selectedRegion","baseCompData","_s","map","markersRef","guerraMarkersRef","competenciaMarkersRef","polylineRef","showingAssociated","setShowingAssociated","activeMercadoPbl","setActiveMercadoPbl","modoCorreccion","setModoCorreccion","makeDraggable","popup","_container","pos","latLngToLayerPoint","getLatLng","DomUtil","setPosition","_wrapper","parentNode","draggable","Draggable","enable","error","console","crearGripEnWrapper","popupContainer","wrapper","querySelector","content","querySelectorAll","forEach","n","remove","handleWheel","e","preventDefault","scrollSpeed","scrollAmount","deltaY","scrollTop","addEventListener","passive","grip","document","createElement","className","appendChild","isResizing","startResize","body","classList","add","style","cursor","userSelect","stopPropagation","doResize","clientX","touches","clientY","gripRect","getBoundingClientRect","gripCenterX","left","width","gripCenterY","top","height","deltaX","Math","abs","currentRect","newWidth","max","newHeight","stopResize","cleanup","removeEventListener","_cleanup","clearCompetenciaMarkers","current","marker","hasLayer","removeLayer","clearPolylines","line","clearGuerraMarkers","Object","values","handleActivateCoords","getContainer","pbl","id","eds","marca","Marca","lat","lng","handleSaveCoords","coordenada","comuna","Comuna","lat_corregida","lon_corregida","m","showAssociatedIds","originalMarkerId","searchArray","length","leafletMarker","createMarkerWithPopup","addLayer","addGuerraMarker","associatedData","filter","item","String","trim","ids","originalMarker","find","associatedMarkers","includes","uniqueAssociatedMarkers","seenIds","Set","has","push","Guerra_Precio","guerraIcon","icon","iconUrl","process","env","PUBLIC_URL","iconSize","iconAnchor","guerraMarker","interactive","mainMarkersData","Marcador_Principal","mainMarker","markerWithCoords","mainLat","parseFloat","mainLng","isNaN","polyline","color","weight","opacity","dashArray","addTo","allMarkers","variant","autoClose","closeOnClick","keepInView","autoPan","maxWidth","setContent","bindPopup","on","container","_contentNode","wrapperContainer","setTimeout","rootDiv","getElementById","_reactRoot","root","createRoot","render","onShowAssociated","onActivateCoords","onSaveCoords","fileName","_jsxFileName","lineNumber","columnNumber","_e$popup","unmount","openPopup","handleMapClick","latlng","prev","eachLayer","layer","getPopup","isOpen","markerId","keys","key","off","_c","$RefreshReg$"],"sources":["C:/Users/e08f/Desktop/Proyectos/Resumen/mapa-v2/src/components/IconMarkersLayer.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { useMap } from 'react-leaflet';\r\nimport L from 'leaflet';\r\nimport ReactDOM from 'react-dom/client';\r\nimport { createCustomIcon } from '../utils/iconHelpers';\r\nimport { guardarCoordenadaCorregida } from '../services/apiService';\r\nimport MapPopup from './MapPopup';\r\nimport '../styles/iconMarkersLayer.css';\r\n\r\nconst IconMarkersLayer = ({ markers, markersForMercado = null, selectedRegion, baseCompData = [] }) => {\r\n  const map = useMap();\r\n  const markersRef = useRef({});\r\n  const guerraMarkersRef = useRef({});\r\n  const competenciaMarkersRef = useRef([]);\r\n  const polylineRef = useRef([]);\r\n\r\n  const [showingAssociated, setShowingAssociated] = useState(false);\r\n  const [activeMercadoPbl, setActiveMercadoPbl] = useState(null);\r\n  const [modoCorreccion, setModoCorreccion] = useState(null);\r\n\r\n  // --- Helpers de UI (Draggable & Resize) ---\r\n  const makeDraggable = useCallback((popup) => {\r\n    if (!map || !popup || !popup._container) return;\r\n    try {\r\n      const pos = map.latLngToLayerPoint(popup.getLatLng());\r\n      L.DomUtil.setPosition(popup._wrapper.parentNode, pos);\r\n      const draggable = new L.Draggable(popup._container, popup._wrapper);\r\n      draggable.enable();\r\n    } catch (error) {\r\n      console.error('Error draggable:', error);\r\n    }\r\n  }, [map]);\r\n\r\n  const crearGripEnWrapper = useCallback((popupContainer) => {\r\n    const wrapper = popupContainer.querySelector('.leaflet-popup-content-wrapper');\r\n    const content = popupContainer.querySelector('.leaflet-popup-content');\r\n    if (!wrapper || !content) return;\r\n\r\n    content?.querySelectorAll('.popup-resize-grip').forEach(n => n.remove());\r\n\r\n    const handleWheel = (e) => {\r\n      e.preventDefault();\r\n      const scrollSpeed = 0.5;\r\n      const scrollAmount = e.deltaY * scrollSpeed;\r\n      content.scrollTop += scrollAmount;\r\n    };\r\n\r\n    content.addEventListener('wheel', handleWheel, { passive: false });\r\n\r\n    let grip = wrapper.querySelector('.popup-resize-grip');\r\n    if (!grip) {\r\n      grip = document.createElement('div');\r\n      grip.className = 'popup-resize-grip';\r\n      wrapper.appendChild(grip);\r\n\r\n      let isResizing = false;\r\n\r\n      const startResize = (e) => {\r\n        isResizing = true;\r\n        document.body.classList.add('is-resizing-popup');\r\n        document.body.style.cursor = 'nwse-resize';\r\n        document.body.style.userSelect = 'none';\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n      };\r\n\r\n      const doResize = (e) => {\r\n        if (!isResizing) return;\r\n\r\n        const clientX = e.clientX || (e.touches && e.touches[0].clientX);\r\n        const clientY = e.clientY || (e.touches && e.touches[0].clientY);\r\n\r\n        const gripRect = grip.getBoundingClientRect();\r\n        const gripCenterX = gripRect.left + gripRect.width / 2;\r\n        const gripCenterY = gripRect.top + gripRect.height / 2;\r\n\r\n        const deltaX = clientX - gripCenterX;\r\n        const deltaY = clientY - gripCenterY;\r\n\r\n        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {\r\n          const currentRect = content.getBoundingClientRect();\r\n          const newWidth = Math.max(240, currentRect.width + deltaX);\r\n          const newHeight = Math.max(180, currentRect.height + deltaY);\r\n\r\n          content.style.width = newWidth + 'px';\r\n          content.style.height = newHeight + 'px';\r\n        }\r\n\r\n        e.preventDefault();\r\n      };\r\n\r\n      const stopResize = () => {\r\n        if (!isResizing) return;\r\n        isResizing = false;\r\n        document.body.classList.remove('is-resizing-popup');\r\n        document.body.style.cursor = '';\r\n        document.body.style.userSelect = '';\r\n      };\r\n\r\n      grip.addEventListener('mousedown', startResize);\r\n      document.addEventListener('mousemove', doResize);\r\n      document.addEventListener('mouseup', stopResize);\r\n\r\n      grip.addEventListener('touchstart', startResize, { passive: false });\r\n      document.addEventListener('touchmove', doResize, { passive: false });\r\n      document.addEventListener('touchend', stopResize);\r\n\r\n      const cleanup = () => {\r\n        content.removeEventListener('wheel', handleWheel);\r\n        document.removeEventListener('mousemove', doResize);\r\n        document.removeEventListener('mouseup', stopResize);\r\n        document.removeEventListener('touchmove', doResize);\r\n        document.removeEventListener('touchend', stopResize);\r\n        document.body.classList.remove('is-resizing-popup');\r\n      };\r\n\r\n      grip._cleanup = cleanup;\r\n    }\r\n  }, []);\r\n\r\n  // --- Helpers de limpieza ---\r\n  const clearCompetenciaMarkers = useCallback(() => {\r\n    competenciaMarkersRef.current.forEach(marker => {\r\n      try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n    });\r\n    competenciaMarkersRef.current = [];\r\n  }, [map]);\r\n\r\n  const clearPolylines = useCallback(() => {\r\n    polylineRef.current.forEach(line => {\r\n      try { if (map && map.hasLayer(line)) map.removeLayer(line); } catch (e) { }\r\n    });\r\n    polylineRef.current = [];\r\n  }, [map]);\r\n\r\n  const clearGuerraMarkers = useCallback(() => {\r\n    Object.values(guerraMarkersRef.current).forEach(marker => {\r\n      try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n    });\r\n    guerraMarkersRef.current = {};\r\n  }, [map]);\r\n\r\n  // --- Handlers ---\r\n  const handleActivateCoords = useCallback((marker) => {\r\n    if (map) map.getContainer().style.cursor = 'crosshair';\r\n    setModoCorreccion({\r\n      pbl: marker.pbl,\r\n      id: marker.id,\r\n      eds: marker.eds,\r\n      marca: marker.Marca,\r\n      lat: null,\r\n      lng: null\r\n    });\r\n  }, [map]);\r\n\r\n  const handleSaveCoords = useCallback(async (marker) => {\r\n    if (!modoCorreccion || !modoCorreccion.lat || !modoCorreccion.lng) return;\r\n\r\n    try {\r\n      const coordenada = {\r\n        id: marker.id || marker.pbl,\r\n        pbl: marker.pbl || marker.id,\r\n        eds: marker.eds || '',\r\n        marca: marker.Marca || '',\r\n        comuna: marker.Comuna || '',\r\n        lat_corregida: modoCorreccion.lat,\r\n        lon_corregida: modoCorreccion.lng\r\n      };\r\n      await guardarCoordenadaCorregida(coordenada);\r\n\r\n      // Actualizar marcador localmente\r\n      marker.lat = modoCorreccion.lat;\r\n      marker.lng = modoCorreccion.lng;\r\n\r\n      // Resetear modo corrección\r\n      setModoCorreccion(null);\r\n      if (map) map.getContainer().style.cursor = '';\r\n\r\n      // Re-renderizar marcadores (esto forzará un update del efecto principal)\r\n      // Nota: En una app real, deberíamos actualizar el estado 'markers' en el padre\r\n      // pero aquí simulamos el refresco limpiando y dejando que el efecto corra.\r\n      // Para simplificar, forzamos un re-render limpiando refs (el efecto lo notará si markers cambia, \r\n      // pero como mutamos el objeto, necesitamos forzar update o confiar en que el padre refresque).\r\n      // Aquí asumimos que el padre refrescará o que el efecto de abajo se encargará si cambiamos algo.\r\n      // Como mutamos 'marker', React no detecta cambio de prop 'markers' si es el mismo array.\r\n      // Forzamos limpieza manual y re-creación:\r\n      Object.values(markersRef.current).forEach(m => {\r\n        if (map.hasLayer(m)) map.removeLayer(m);\r\n      });\r\n      markersRef.current = {};\r\n      clearGuerraMarkers();\r\n\r\n      // Disparamos un evento custom o callback si fuera necesario, \r\n      // por ahora confiamos en que el usuario recargue o que el efecto se dispare si cambiamos algo de estado.\r\n      // Un truco es setear un estado dummy para forzar re-render, pero mejor dejemos que el flujo siga.\r\n\r\n    } catch (error) {\r\n      console.error(\"Error guardando coordenadas:\", error);\r\n    }\r\n  }, [modoCorreccion, map, clearGuerraMarkers]);\r\n\r\n\r\n  // --- Lógica de Mercado (Show Associated) ---\r\n  const showAssociatedIds = useCallback((pbl, lat, lng, originalMarkerId) => {\r\n    const searchArray = markersForMercado && markersForMercado.length > 0 ? markersForMercado : markers;\r\n\r\n    if (showingAssociated && activeMercadoPbl === pbl) {\r\n      // Toggle OFF\r\n      clearCompetenciaMarkers();\r\n      clearPolylines();\r\n      setShowingAssociated(false);\r\n      setActiveMercadoPbl(null);\r\n\r\n      // Restaurar marcadores originales\r\n      Object.values(markersRef.current).forEach(marker => {\r\n        try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n      });\r\n      markersRef.current = {};\r\n\r\n      // Re-crear todos\r\n      markers.forEach(marker => {\r\n        const leafletMarker = createMarkerWithPopup(marker, markersForMercado || markers, 'primary');\r\n        if (leafletMarker) {\r\n          map.addLayer(leafletMarker);\r\n          markersRef.current[marker.id] = leafletMarker;\r\n          addGuerraMarker(marker);\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Toggle ON (o cambio de PBL)\r\n    clearCompetenciaMarkers();\r\n    clearPolylines();\r\n\r\n    const associatedData = baseCompData.filter(item => String(item.pbl).trim() === String(pbl).trim());\r\n    if (associatedData.length === 0) return;\r\n\r\n    const ids = associatedData.map(item => item.id);\r\n\r\n    // Limpiar actuales\r\n    Object.values(markersRef.current).forEach(marker => {\r\n      try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n    });\r\n    markersRef.current = {};\r\n    clearGuerraMarkers();\r\n\r\n    // Mostrar original\r\n    const originalMarker = markers.find(m => m.id === originalMarkerId);\r\n    if (originalMarker) {\r\n      const leafletMarker = createMarkerWithPopup(originalMarker, markersForMercado || markers, 'primary');\r\n      if (leafletMarker) {\r\n        map.addLayer(leafletMarker);\r\n        markersRef.current[originalMarker.id] = leafletMarker;\r\n        addGuerraMarker(originalMarker);\r\n      }\r\n    }\r\n\r\n    // Mostrar competencia\r\n    const associatedMarkers = searchArray.filter(item => ids.includes(item.id));\r\n    const uniqueAssociatedMarkers = [];\r\n    const seenIds = new Set();\r\n    associatedMarkers.forEach(marker => {\r\n      if (!seenIds.has(marker.id)) {\r\n        seenIds.add(marker.id);\r\n        uniqueAssociatedMarkers.push(marker);\r\n      }\r\n    });\r\n\r\n    uniqueAssociatedMarkers.forEach(marker => {\r\n      const leafletMarker = createMarkerWithPopup(marker, markersForMercado || baseCompData, 'secondary');\r\n      if (leafletMarker) {\r\n        map.addLayer(leafletMarker);\r\n        competenciaMarkersRef.current.push(leafletMarker);\r\n        if (marker.Guerra_Precio === 'Si') {\r\n          // Guerra marker logic for secondary\r\n          const guerraIcon = L.icon({\r\n            iconUrl: `${process.env.PUBLIC_URL}/iconos/calavera.jpg`,\r\n            iconSize: [15, 15],\r\n            iconAnchor: [7.5, 7.5],\r\n            className: 'icono-guerra'\r\n          });\r\n          const guerraMarker = L.marker([marker.lat, marker.lng], { icon: guerraIcon, interactive: false });\r\n          map.addLayer(guerraMarker);\r\n          // No lo guardamos en ref global para no borrarlo accidentalmente con clearGuerraMarkers si solo queremos borrar los principales, \r\n          // aunque aquí borramos todo al cambiar de vista.\r\n          // Para simplificar, los agregamos a competenciaMarkersRef si queremos limpiarlos con eso, o los dejamos sueltos (pero hay que limpiarlos).\r\n          // Mejor los metemos en competenciaMarkersRef también (aunque sean markers distintos).\r\n          competenciaMarkersRef.current.push(guerraMarker);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Polylines\r\n    const mainMarkersData = associatedData.filter(m => m.Marcador_Principal === 'Si');\r\n    mainMarkersData.forEach(mainMarker => {\r\n      const markerWithCoords = searchArray.find(m => m.id === mainMarker.id);\r\n      if (!markerWithCoords) return;\r\n      const mainLat = parseFloat(markerWithCoords.lat);\r\n      const mainLng = parseFloat(markerWithCoords.lng);\r\n      if (isNaN(mainLat) || isNaN(mainLng)) return;\r\n\r\n      const polyline = L.polyline(\r\n        [[parseFloat(lat), parseFloat(lng)], [mainLat, mainLng]],\r\n        { color: '#FF6B6B', weight: 3, opacity: 0.8, dashArray: '5, 5' }\r\n      ).addTo(map);\r\n      polylineRef.current.push(polyline);\r\n    });\r\n\r\n    setShowingAssociated(true);\r\n    setActiveMercadoPbl(pbl);\r\n\r\n  }, [baseCompData, markers, markersForMercado, map, showingAssociated, activeMercadoPbl, clearCompetenciaMarkers, clearPolylines, clearGuerraMarkers]); // createMarkerWithPopup is defined below, using ref to avoid circular dep or hoisting issues if possible, or just define it before.\r\n\r\n  // Helper para Guerra Marker\r\n  const addGuerraMarker = (marker) => {\r\n    if (marker.Guerra_Precio === 'Si') {\r\n      const guerraIcon = L.icon({\r\n        iconUrl: `${process.env.PUBLIC_URL}/iconos/calavera.jpg`,\r\n        iconSize: [15, 15],\r\n        iconAnchor: [7.5, 7.5],\r\n        className: 'icono-guerra'\r\n      });\r\n      const guerraMarker = L.marker([marker.lat, marker.lng], { icon: guerraIcon, interactive: false });\r\n      map.addLayer(guerraMarker);\r\n      guerraMarkersRef.current[marker.id] = guerraMarker;\r\n    }\r\n  };\r\n\r\n  // --- Crear Marcador con Popup React ---\r\n  const createMarkerWithPopup = useCallback((marker, allMarkers, variant = 'primary') => {\r\n    const lat = parseFloat(marker.lat);\r\n    const lng = parseFloat(marker.lng);\r\n    if (isNaN(lat) || isNaN(lng)) return null;\r\n\r\n    const iconUrl = createCustomIcon(marker.Marca);\r\n    const leafletMarker = L.marker([lat, lng], { icon: iconUrl });\r\n\r\n    // Popup vacío inicial\r\n    const popup = L.popup({\r\n      autoClose: false,\r\n      closeOnClick: false,\r\n      keepInView: true,\r\n      autoPan: false,\r\n      maxWidth: 450,\r\n      className: 'custom-popup'\r\n    }).setContent('<div id=\"popup-root-' + marker.id + '\"></div>');\r\n\r\n    leafletMarker.bindPopup(popup);\r\n\r\n    // Renderizar React en el Popup al abrir\r\n    leafletMarker.on('popupopen', (e) => {\r\n      makeDraggable(popup);\r\n      const container = e.popup._contentNode; // o _container\r\n      const wrapperContainer = e.popup._container;\r\n      if (wrapperContainer) {\r\n        crearGripEnWrapper(wrapperContainer);\r\n      }\r\n      // Buscar el div root que pusimos\r\n      // Buscar el div root que pusimos\r\n      // Nota: Leaflet a veces envuelve el contenido.\r\n      // Mejor estrategia: usar el contenido del popup como container.\r\n\r\n      // Esperamos un tick para asegurar que el DOM existe\r\n      setTimeout(() => {\r\n        const rootDiv = document.getElementById('popup-root-' + marker.id);\r\n        if (rootDiv && !rootDiv._reactRoot) {\r\n          const root = ReactDOM.createRoot(rootDiv);\r\n          rootDiv._reactRoot = root;\r\n          root.render(\r\n            <MapPopup\r\n              marker={marker}\r\n              allMarkers={allMarkers}\r\n              onShowAssociated={showAssociatedIds}\r\n              onActivateCoords={handleActivateCoords}\r\n              onSaveCoords={handleSaveCoords}\r\n              onSaveCoords={handleSaveCoords}\r\n              modoCorreccion={modoCorreccion}\r\n              variant={variant}\r\n            />\r\n          );\r\n        }\r\n      }, 0);\r\n    });\r\n\r\n    leafletMarker.on('popupclose', (e) => {\r\n      const container = e.popup?._container;\r\n      if (container) {\r\n        const wrapper = container.querySelector('.leaflet-popup-content-wrapper');\r\n        const grip = wrapper?.querySelector('.popup-resize-grip');\r\n        if (grip && grip._cleanup) {\r\n          grip._cleanup();\r\n        }\r\n      }\r\n\r\n      const rootDiv = document.getElementById('popup-root-' + marker.id);\r\n      if (rootDiv && rootDiv._reactRoot) {\r\n        // Desmontar para evitar leaks\r\n        // rootDiv._reactRoot.unmount(); // A veces da problemas si se cierra muy rápido, pero es buena práctica.\r\n        // Dejamos que React maneje la limpieza si es posible, o unmount explícito.\r\n        setTimeout(() => {\r\n          if (rootDiv._reactRoot) {\r\n            rootDiv._reactRoot.unmount();\r\n            rootDiv._reactRoot = null;\r\n          }\r\n        }, 0);\r\n      }\r\n    });\r\n\r\n    return leafletMarker;\r\n  }, [showAssociatedIds, handleActivateCoords, handleSaveCoords, modoCorreccion, makeDraggable, crearGripEnWrapper]);\r\n\r\n\r\n  // --- Efecto Principal de Renderizado ---\r\n  useEffect(() => {\r\n    if (!map || !markers || markers.length === 0) return;\r\n\r\n    // Si estamos mostrando asociados, no refrescamos todo (a menos que cambien los filtros drásticamente, \r\n    // pero aquí asumimos que si 'markers' cambia, reseteamos vista).\r\n    // Para simplificar: si markers cambia, reseteamos todo.\r\n\r\n    clearCompetenciaMarkers();\r\n    clearPolylines();\r\n    setShowingAssociated(false);\r\n    setActiveMercadoPbl(null);\r\n\r\n    Object.values(markersRef.current).forEach(marker => {\r\n      try { if (map && map.hasLayer(marker)) map.removeLayer(marker); } catch (e) { }\r\n    });\r\n    markersRef.current = {};\r\n    clearGuerraMarkers();\r\n\r\n    markers.forEach(marker => {\r\n      const leafletMarker = createMarkerWithPopup(\r\n        marker,\r\n        markersForMercado || markers,\r\n        'primary'\r\n      );\r\n      if (leafletMarker) {\r\n        map.addLayer(leafletMarker);\r\n        markersRef.current[marker.id] = leafletMarker;\r\n        addGuerraMarker(marker);\r\n      }\r\n    });\r\n\r\n    if (markers.length === 1 && markersRef.current[markers[0].id]) {\r\n      markersRef.current[markers[0].id].openPopup();\r\n    }\r\n\r\n  }, [map, markers, markersForMercado, selectedRegion, clearCompetenciaMarkers, clearPolylines, clearGuerraMarkers, createMarkerWithPopup]);\r\n\r\n\r\n  // --- Efecto para Click en Mapa (Corrección Coordenadas) ---\r\n  useEffect(() => {\r\n    if (!map || !modoCorreccion) return;\r\n\r\n    const handleMapClick = (e) => {\r\n      const { lat, lng } = e.latlng;\r\n      setModoCorreccion(prev => ({ ...prev, lat, lng }));\r\n\r\n      // Actualizar UI del popup si está abierto?\r\n      // Como el popup se renderiza con 'modoCorreccion' como prop, \r\n      // necesitamos que se re-renderice.\r\n      // Al cambiar el estado 'modoCorreccion', el componente IconMarkersLayer se re-renderiza.\r\n      // Pero los popups ya abiertos son árboles de React independientes montados en nodos DOM.\r\n      // NO se actualizarán automáticamente con las nuevas props porque createMarkerWithPopup se recrea\r\n      // pero los popups ya montados no reciben las nuevas props a menos que los actualicemos explícitamente.\r\n\r\n      // SOLUCIÓN: Cerrar y abrir popup es brusco.\r\n      // Mejor: Usar un Context o un Store simple, o forzar update.\r\n      // Dado que 'createMarkerWithPopup' depende de 'modoCorreccion', \r\n      // cuando 'modoCorreccion' cambia, la función cambia.\r\n      // Pero los markers ya están en el mapa.\r\n\r\n      // Para esta refactorización rápida, podemos aceptar que el usuario cierre y abra, \r\n      // O intentar actualizar el popup activo.\r\n      // Lo más simple y robusto en React-Leaflet \"vanilla\" es difícil.\r\n      // Sin embargo, como MapPopup es hijo de IconMarkersLayer (indirectamente), \r\n      // NO lo es. Es un árbol nuevo.\r\n\r\n      // TRUCO: Disparar un evento custom que MapPopup escuche, o usar un ref mutable.\r\n      // O simplemente re-renderizar el contenido del popup activo.\r\n\r\n      // Vamos a iterar sobre los popups abiertos y re-renderizarlos.\r\n      map.eachLayer(layer => {\r\n        if (layer.getPopup && layer.getPopup() && layer.getPopup().isOpen()) {\r\n          const markerId = Object.keys(markersRef.current).find(key => markersRef.current[key] === layer);\r\n          if (markerId) {\r\n            const marker = markers.find(m => m.id === markerId) || (markersForMercado || []).find(m => m.id === markerId);\r\n            if (marker) {\r\n              const rootDiv = document.getElementById('popup-root-' + marker.id);\r\n              if (rootDiv && rootDiv._reactRoot) {\r\n                rootDiv._reactRoot.render(\r\n                  <MapPopup\r\n                    marker={marker}\r\n                    allMarkers={markersForMercado || markers}\r\n                    onShowAssociated={showAssociatedIds}\r\n                    onActivateCoords={handleActivateCoords}\r\n                    onSaveCoords={handleSaveCoords}\r\n                    onSaveCoords={handleSaveCoords}\r\n                    modoCorreccion={{ ...modoCorreccion, lat, lng }} // Pasamos el nuevo valor\r\n                    variant={markersForMercado && markersForMercado.includes(marker) ? 'secondary' : 'primary'} // Aproximación, mejor pasar variant si pudiéramos\r\n                  />\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    map.on('click', handleMapClick);\r\n    return () => { map.off('click', handleMapClick); };\r\n  }, [map, modoCorreccion, markers, markersForMercado, showAssociatedIds, handleActivateCoords, handleSaveCoords]);\r\n\r\n\r\n  return null;\r\n};\r\n\r\nexport default IconMarkersLayer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}